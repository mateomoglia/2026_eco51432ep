---
title: "Data visualisation"
format: html
editor: visual
toc: true
toc-title: ""
toc-location: right
---

```{r, echo=F,eval=T,message=F,warning=F}
packages <- c("ggplot2", "readxl", "dplyr", "tidyr","xtable","sf")
# Install packages not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}
# Packages loading
invisible(lapply(packages, library, character.only = TRUE))
path = "C:/Users/mateomoglia/Dropbox/courses/polytechnique/2026_eco51432ep"
idf_data = read.csv2(paste0(path,"/temp/idf_data.csv")) %>%
        mutate(log_loy_appartement = log(loy_appartement),
               log_loy_house       = log(loy_house),
               log_popmun = log(popmun))
```

## Roadmap

In this part, we are going to learn how to:

-   Use georeferenced data
-   Compute distances
-   Make maps

## A primer on spatial data

We are going to take advantage of the`/temp/idf_data.csv` we built earlier on, `monu_histo.csv` containing the list of all monuments listed in Ile-de-France with the zip code, `gares.shp` listing all stations in the Île-de-France train network, with their associated location.

### Shapefiles 

Spatial data can come in different format but the most popular one is the shapefile `.shp`. As the name suggested, it is a file containing **shapes**. Most common shapes are: `POINTS`, `LINES`, `POLYGONS`. As the `.csv` format, each line contains a shape and can contain other information. Spatial data are usually [spatially projected](https://en.wikipedia.org/wiki/Well-known_text_representation_of_coordinate_reference_systems). The most common projection in Western countries is the Mercator projection. In Europe, the projection is usually WGS84. In France, the projection is Lambert 93. Projection also contains information on the units (meters or degrees or kilometers), the position with respect to the meridians, etc. 

Shapefiles are delivered in folders containing at least 3 files: `.dbf` (with the data), `.shx` (indexing the geometry to the data), `.shp` (containing the shapes). Usually, we find also a `.prj` (the projection of the data). You need to have all files within the same folder to be able to load the `.shp` with any software (such as QGIS, Stata, R, ArcGIS, or others). 

### Spatial data in R

Spatial data can be opened in R thanks to `sf` package. To open a shapefile, the function is `sf::read_sf()`. It creates a specific object type, an `sf` object in R. All objects of that type contain a column `geometry` by default. To transform an `sf` object into a `data.frame` again, the good practice is `df = df_sf %>% st_drop_geometry() %>% as.data.frame()`. 

Most functions (plots, summarize, joint) are compatible with `sf` objects. However, due to their spatial features, we can apply many other (similar) functions. 

## Price gradient

The objective is to descriptively assess a relationship (although non-causal) between rents and the distance to the Eiffel Tower. Let's do it step-by-step:

1.  Open the shapefiles of cities 

```{r, echo = T, eval = T}
co_shp = read_sf(paste0(path,"/raw_data/communes.shp")) %>%
        select(insee, geometry, nomcom) %>%
        rename(codgeo = insee) # Prepare the match for the further use
```

2.  Open the monument data and make it a shapefile

```{r, echo = T, eval = T}
eiffel = read.csv2(paste0(path,"/raw_data/monu_histo.csv")) %>%
        filter(eiffel == 1) %>%
        st_as_sf(coords = c("y_wgs84","x_wgs84"), crs = st_crs(co_shp))
```

Here, notice that we set the `crs` (the projection) of the shape so that it matches the one from cities. 

3.  Compute the distance between each city centroid and the Eiffel Tower
```{r, echo = T, eval = T}
co_eiffel = co_shp %>%
        mutate(centroid = st_centroid(geometry)) %>%
        mutate(distance = as.numeric(st_distance(centroid,eiffel$geometry[1]))/1000) %>%
        select(-centroid) 
```

4.  Plot the price gradient
```{r, eval = T, echo = F}
co_eiffel %>%
        st_drop_geometry() %>%
        select(codgeo, distance) %>%
        left_join(idf_data %>% select(codgeo, loy_appartement, loy_house)) %>%
        ggplot(aes(x = distance, y = loy_appartement)) +
        geom_point(aes(colour = "Obs.")) +
        geom_smooth(formula = y ~ poly(x, 2), aes(colour = "Polynomial")) +
        geom_smooth(method = "lm", aes(colour = "Linear")) +
        labs(x = "Distance to the Eiffel Tower", y = "Rent", colour = NULL) +
        scale_color_manual(values = c("Linear" = "red", "Polynomial" = "blue", "Obs." = "black"),
                           breaks = c("Obs.","Linear","Polynomial")) +
        theme_classic() +
        theme(legend.position = "bottom",
              panel.grid.major = element_line(colour = "darkgray", linetype = "dashed"),
              panel.grid.minor = element_blank())
```

:::callout-tip
## Exercise (if time allows)

Do it yourself!
:::

## Maps

### Train stations in Ile-de-France

The point is to plot the average distance to the nearest train station for each city in Ile-de-France.

```{r, echo = T, eval = F}
      stations = read_sf(paste0(path,"/raw_data/gares.shp")) %>%
        select(mode,exploitant,geometry)
      
      # Visualize the stations
      ggplot() +
        geom_sf(data = co_shp) +
        geom_sf(data = stations, size = 0.4) +
        theme_void()

      # Remove the stations out of IDF
      idf_stations = stations %>%
        st_join(co_shp, join = st_within, left = FALSE)
      
      # Visualize the stations
      ggplot() +
        geom_sf(data = co_shp) +
        geom_sf(data = idf_stations, size = 0.4) +
        theme_void()
      
      # Keep only those with a RER 
      idf_stations_rer = idf_stations %>%
        filter(grepl("RER", mode))

      # Distance between the centroids and the nearest RER station + map
      co_shp %>%
        mutate(centroid = st_centroid(geometry)) %>%
        mutate(distance = as.numeric(st_distance(centroid, idf_stations_rer) %>% apply(1, min))/1000) %>%
        select(-centroid) %>%
        ggplot() +
        geom_sf(aes(fill = distance), colour = NA) +
        scale_fill_viridis_c(option = "B", name = NULL) +
        theme_void() +
        labs(title = "Distance (km) to the nearest station") +
        theme(plot.title = element_text(colour = "black", face = "bold", hjust = 0.5, size = 14))
```

:::callout-tip
## Exercise 

Following the work on the train stations, we would like to make two maps: one with the total number of stops per city (outside of Paris but still plotting Paris!!) and one with the total number of RER stops per city.

1.  Open the stations and municipal shapefiles
2.  Keep only stations within Ile de France and outside Paris
3.  Summarize by municipality the count of stations (total and only RER)
4.  Make the maps using `geom_sf()`
5.  Add a label to tag the city the most stations

:::

### Merging geometries

One last element I believe is important is the spatial manipulation of geometries. `sf` is an extremely powerful package to manipulate geometries altogether. If you use spatial data, you may want for instance to crop geometries to keep the intersection (then `st_intersection` is your friend). Here, we use `st_union()` to merge geometries together. 

Because we have municipalities, we may want to plot based on _département_ instead. Hence, we use `summarize(geometry = sf::st_union(geometry))` to merge geometries by group:

```{r, echo = T, eval = F}
dep_shp = co_shp %>%
        group_by(dep = substr(codgeo,1,2)) %>%
        summarize(geometry = st_union(geometry))
```

:::callout-tip
## Exercise

Plot the number of monuments per département
:::